using SolarEcs.Infrastructure;
using SolarEcs.Queries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace SolarEcs
{
    public static partial class QueryPlan
    {
        /// <summary>
        /// Changes the keys of this query plan to those generated by an expression.  Duplicate keys are allowed.
        /// The resulting query will contain the same number of elements as this query.  Element models will be unchanged.
        /// Example: {K1, M1}, {K2, M2} -> {relation(M1), M1}, {relation(M2), M2}
        /// </summary>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="keySelector">The expression to generate the keys for the new query from each model in this query.</param>
        /// <returns></returns>
        public static IQueryPlan<TResult> ShiftKey<TKeyStart, TResult>(this IQueryPlan<TKeyStart, TResult> query, Expression<Func<IKeyWith<TKeyStart, TResult>, Guid>> keySelector)
        {
            if (query.State == QueryPlanState.Empty)
            {
                return Empty<TResult>();
            }

            return new ShiftKeyQueryPlan<TKeyStart, Guid, TResult>(query, keySelector).AsEntityQuery();
        }

        /// <summary>
        /// Changes the keys of this query plan to those generated by an expression.  Duplicate keys are allowed.
        /// The resulting query will contain the same number of elements as this query.  Element models will be unchanged.
        /// Example: {K1, M1}, {K2, M2} -> {relation({K1, M1}), M1}, {relation({K2, M2}), M2}
        /// </summary>
        /// <typeparam name="TKeyStart"></typeparam>
        /// <typeparam name="TKeyEnd"></typeparam>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="keySelector">The expression to generate the keys for the new query from each element in this query.</param>
        /// <returns></returns>
        public static IQueryPlan<TKeyEnd, TResult> ShiftKey<TKeyStart, TKeyEnd, TResult>(this IQueryPlan<TKeyStart, TResult> query, Expression<Func<IKeyWith<TKeyStart, TResult>, TKeyEnd>> keySelector)
        {
            if (query.State == QueryPlanState.Empty)
            {
                return Empty<TKeyEnd, TResult>();
            }

            return new ShiftKeyQueryPlan<TKeyStart, TKeyEnd, TResult>(query, keySelector);
        }
    }
}

namespace SolarEcs.Queries
{
    public class ShiftKeyQueryPlan<TKeyStart, TKeyEnd, TResult> : IQueryPlan<TKeyEnd, TResult>
    {
        private IQueryPlan<TKeyStart, TResult> BaseQuery { get; set; }
        private Expression<Func<IKeyWith<TKeyStart, TResult>, TKeyEnd>> KeySelector { get; set; }

        public ShiftKeyQueryPlan(IQueryPlan<TKeyStart, TResult> baseQuery, Expression<Func<IKeyWith<TKeyStart, TResult>, TKeyEnd>> keySelector)
        {
            this.BaseQuery = baseQuery;
            this.KeySelector = keySelector;
        }

        public QueryPlanState State
        {
            get { return BaseQuery.State; }
        }

        public IEnumerable<IKeyWith<TKeyEnd, TResult>> Execute(Expression<Func<TKeyEnd, bool>> predicate)
        {
            if (State == QueryPlanState.Materialized)
            {
                var keySelectorCompiled = KeySelector.Compile();
                var predicateCompiled = predicate.Compile();

                return BaseQuery.ExecuteAll()
                    .Where(o => predicateCompiled(keySelectorCompiled(o)))
                    .Select(o => new KeyWith<TKeyEnd, TResult>(keySelectorCompiled(o), o.Model));
            }
            else
            {
                return ImmaterialQuery.Where(predicate.ForKeyWith<TKeyEnd, TResult>()).ToList();
            }
        }

        public IQueryable<IKeyWith<TKeyEnd, TResult>> ImmaterialQuery
        {
            get
            {
                var fullSelector = CreateFullSelector();
                return BaseQuery.ImmaterialQuery.Select(fullSelector);
            }
        }

        private Expression<Func<IKeyWith<TKeyStart, TResult>, KeyWith<TKeyEnd, TResult>>> CreateFullSelector()
        {
            var param = KeySelector.Parameters[0];
            var componentProperty = Expression.Property(param, "Model");

            var entityWithConstructor = typeof(KeyWith<TKeyEnd, TResult>).GetConstructor(new Type[] { typeof(TKeyEnd), typeof(TResult) });

            var body = Expression.New(entityWithConstructor, KeySelector.Body, componentProperty);
            var safeBody = QueryExpressions.Clean(body);

            return (Expression<Func<IKeyWith<TKeyStart, TResult>, KeyWith<TKeyEnd, TResult>>>)Expression.Lambda(safeBody, param);
        }
    }
}
