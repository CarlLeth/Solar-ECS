using SolarEcs.Infrastructure;
using SolarEcs.Queries;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace SolarEcs
{
    public static partial class QueryPlan
    {
        /// <summary>
        /// Groups the elements of this IQueryPlan by the keys generated by groupKeySelector.  Models associated to the same generated key will be grouped into the same IEnumerable.
        /// The resulting query plan will contain one element per distinct key generated.  The key of each element will be the generated key, and the model will be an IEnumerable
        /// of all models associated with a key which is mapped to the generated key by groupKeySelector.
        /// Functionally equivalent to ShiftKey(groupKeySelector).GroupByKey().
        /// </summary>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="groupKeySelector">An expression to map the models of this query plan to group keys.</param>
        /// <returns></returns>
        public static IQueryPlan<IEnumerable<TResult>> GroupBy<TResult>(this IQueryPlan<Guid, TResult> query, Expression<Func<TResult, Guid>> groupKeySelector)
        {
            if (query.State == QueryPlanState.Empty)
            {
                return Empty<IEnumerable<TResult>>();
            }

            return new GroupByQueryPlan<Guid, Guid, TResult>(query, groupKeySelector).AsEntityQuery();
        }

        /// <summary>
        /// Groups the elements of this IQueryPlan by the keys generated by groupKeySelector and applies an aggregation to each result.
        /// Models associated to the same generated key will be grouped into the same IEnumerable and aggregated by the given selector.
        /// The resulting query plan will contain one element per distinct key generated.
        /// The key of each element will be the generated key, and the model will be the result of the aggregation selector applied to
        /// all models associated with a key which is mapped to the generated key by groupKeySelector.
        /// Functionally equivalent to ShiftKey(groupKeySelector).GroupByKey().Select(aggregateResultSelector).
        /// </summary>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="groupKeySelector">An expression to map the models of this query plan to group keys.</param>
        /// <param name="aggregateResultSelector">An expression to map the results of the grouping to an aggregated result.</param>
        /// <returns></returns>
        public static IQueryPlan<TAggregate> GroupBy<TModel, TAggregate>(this IQueryPlan<Guid, TModel> query, Expression<Func<TModel, Guid>> groupKeySelector,
            Expression<Func<IEnumerable<TModel>, TAggregate>> aggregateResultSelector)
        {
            return query.GroupBy(groupKeySelector).Select(aggregateResultSelector);
        }

        /// <summary>
        /// Groups the elements of this IQueryPlan by the keys generated by groupKeySelector.  Models associated to the same generated key will be grouped into the same IEnumerable.
        /// The resulting query plan will contain one element per distinct key generated.  The key of each element will be the generated key, and the model will be an IEnumerable
        /// of all models associated with a key which is mapped to the generated key by groupKeySelector.
        /// Functionally equivalent to ShiftKey(groupKeySelector).GroupByKey().
        /// </summary>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="groupKeySelector">An expression to map the models of this query plan to group keys.</param>
        /// <returns></returns>
        public static IQueryPlan<TKeyGroup, IEnumerable<TResult>> GroupBy<TKeyStart, TKeyGroup, TResult>(this IQueryPlan<TKeyStart, TResult> query, Expression<Func<TResult, TKeyGroup>> groupKeySelector)
        {
            if (query.State == QueryPlanState.Empty)
            {
                return Empty<TKeyGroup, IEnumerable<TResult>>();
            }

            return new GroupByQueryPlan<TKeyStart, TKeyGroup, TResult>(query, groupKeySelector);
        }

        /// <summary>
        /// Groups the elements of this IQueryPlan by the keys generated by groupKeySelector and applies an aggregation to each result.
        /// Models associated to the same generated key will be grouped into the same IEnumerable and aggregated by the given selector.
        /// The resulting query plan will contain one element per distinct key generated.
        /// The key of each element will be the generated key, and the model will be the result of the aggregation selector applies to
        /// all models associated with a key which is mapped to the generated key by groupKeySelector.
        /// Functionally equivalent to ShiftKey(groupKeySelector).GroupByKey().
        /// </summary>
        /// <typeparam name="TResult"></typeparam>
        /// <param name="query">This query plan.</param>
        /// <param name="groupKeySelector">An expression to map the models of this query plan to group keys.</param>
        /// <param name="aggregateResultSelector">An expression to map the results of the grouping to an aggregated result.</param>
        /// <returns></returns>
        public static IQueryPlan<TKeyGroup, TAggregate> GroupBy<TKeyStart, TKeyGroup, TModel, TAggregate>(this IQueryPlan<TKeyStart, TModel> query, Expression<Func<TModel, TKeyGroup>> groupKeySelector,
            Expression<Func<IEnumerable<TModel>, TAggregate>> aggregateResultSelector)
        {
            return query.GroupBy(groupKeySelector).Select(aggregateResultSelector);
        }

        /// <summary>
        /// Groups all results of this query plan into a single IEnumerable result with a random key.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="query"></param>
        /// <returns></returns>
        public static IQueryPlan<IEnumerable<T>> GroupAll<T>(this IQueryPlan<T> query)
        {
            var groupId = Guid.NewGuid();
            return query.GroupBy(o => groupId);
        }

        public static IQueryPlan<TKey, IEnumerable<TResult>> GroupAll<TKey, TResult>(this IQueryPlan<TKey, TResult> query)
        {
            var groupId = default(TKey);
            return query.GroupBy(o => groupId);
        }
    }
}

namespace SolarEcs.Queries
{
    public class GroupByQueryPlan<TKeyStart, TKeyGroup, TResult> : IQueryPlan<TKeyGroup, IEnumerable<TResult>>
    {
        public IQueryPlan<TKeyStart, TResult> BaseQuery { get; private set; }
        public Expression<Func<TResult, TKeyGroup>> GroupKeySelector { get; private set; }

        public GroupByQueryPlan(IQueryPlan<TKeyStart, TResult> baseQuery, Expression<Func<TResult, TKeyGroup>> groupKeySelector)
        {
            this.BaseQuery = baseQuery;
            this.GroupKeySelector = groupKeySelector;
        }

        public QueryPlanState State
        {
            get { return BaseQuery.State; }
        }

        public IEnumerable<IKeyWith<TKeyGroup, IEnumerable<TResult>>> Execute(Expression<Func<TKeyGroup, bool>> predicate)
        {
            if (BaseQuery.State == QueryPlanState.Materialized)
            {
                var groupKeySelectorCompiled = GroupKeySelector.Compile();
                var predicateCompiled = predicate.Compile();

                return BaseQuery.ExecuteAll()
                    .GroupBy(o => groupKeySelectorCompiled(o.Model))
                    .Where(o => predicateCompiled(o.Key))
                    .Select(grp => new KeyWith<TKeyGroup, IEnumerable<TResult>>(grp.Key, grp.Select(o => o.Model)));
            }
            else
            {
                return ImmaterialQuery.Where(predicate.ForKeyWith<TKeyGroup, IEnumerable<TResult>>()).ToList();
            }
        }

        public IQueryable<IKeyWith<TKeyGroup, IEnumerable<TResult>>> ImmaterialQuery
        {
            get
            {
                var param = Expression.Parameter(typeof(IKeyWith<TKeyStart, TResult>));
                var paramResult = Expression.Property(param, "Model");

                var parameterExpressionVisitor = new ParameterReplacingExpressionVisitor();
                parameterExpressionVisitor.AddReplacementRule(GroupKeySelector.Parameters[0], paramResult);

                var selectorBody = QueryExpressions.Clean(parameterExpressionVisitor.Visit(GroupKeySelector.Body));
                var selector = Expression.Lambda(selectorBody, param) as Expression<Func<IKeyWith<TKeyStart, TResult>, TKeyGroup>>;

                return BaseQuery
                    .ImmaterialQuery
                    .GroupBy(QueryExpressions.Clean(selector))
                    .Select(grp => new KeyWith<TKeyGroup, IEnumerable<TResult>> { Key = grp.Key, Model = grp.Select(o => o.Model) });
            }
        }
    }
}
